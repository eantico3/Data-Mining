# -*- coding: utf-8 -*-
"""HomeworkTwo_Emily_An.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/139nM2OFrR7_AWRR1RQH7p5_FXRLpiQTa
"""

import numpy as np
import pandas as pd

from pandas import Series, DataFrame

pd.set_option('precision', 2)
np.set_printoptions(precision=2)

#Question 1 Find out the size of the dataset and information about columns such as names, types of
#data. 


df = pd.read_csv('http://storm.cis.fordham.edu/~yli/data/small_telco_Homework2.csv')

df.info()
df

#Question 2 2. Find the statistics information of all columns with numerical values.

df.describe(include=[np.number])

#Question 3 Values of columns such as region, internet and class are categorical data, however, the
#system detected them as numerical values by default.


df['region'] = df['region'].astype('category')
df['internet'] = df['internet'].astype('category')
df['class'] = df['class'].astype('category')

#Question 4 Draw three bar plots for the above mentioned three categorical data columns

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt 
# %matplotlib inline
import seaborn as sns

df['region'].value_counts().sort_index().plot.bar()

df['internet'].value_counts().sort_index().plot.bar()

df['class'].value_counts().sort_index().plot.bar()

#Question 5 Draw density plots for columns with numerical data, such as age, income, long_Month,
#longten, and balance. 

df['age'].plot.density() #density plot for age

df['income'].plot.density() #density plot for income

df['long_Month'].plot.density() #density plot for long_Month

df['longten'].plot.density() #density plot for longten

df['balance'].plot.density() #density plot for balance

#Question 6  Check whether columns with numerical data have outliers by drawing box plots (use the
#formula we discussed in class), if they do, replace them with the closer boundary.

#Box Plot for Age

df['age'].plot.box(whis=2) #no outliers

#Box Plot for Income

df['income'].plot.box(whis=2) #outliers found

def check_outliers(x):
  q25 = x.quantile(.25)
  q75 = x.quantile(.75)
  IQR = q75-q25
  l =  q25 - IQR*1.5
  u = q75 + IQR*1.5
  return 1, u

lower, upper = check_outliers(df['income'])
print(f'lower = {lower}, upper={upper}')

mask_lower = df[df['income'] < lower]
mask_lower # no lower income than lower bound

mask_upper = df[df['income'] > upper]
mask_upper

df['new_income'] = df['income']
for i in mask_upper.index: #replace outliers with upper boundary
  df.loc[i,'new_income'] = upper

mask2_upper = df[df['new_income']> upper] #check outliers were changed
mask2_upper

#Box Plot for long_Month

df['long_Month'].plot.box(whis=2) #outliers found

lower, upper = check_outliers(df['long_Month'])
print(f'lower = {lower}, upper={upper}')

mask_lower = df[df['long_Month'] < lower]
mask_lower # no lower value than lower bound

mask_upper = df[df['long_Month'] > upper]
mask_upper

df['new_long_Month'] = df['long_Month']
for i in mask_upper.index: #replace outliers with upper boundary
  df.loc[i,'new_long_Month'] = upper

mask2_upper = df[df['new_long_Month'] > upper] #check that outliers were replaced with bounds
mask2_upper

#Box Plot for Longten

df['longten'].plot.box(whis=2) #outliers found

lower, upper = check_outliers(df['longten'])
print(f'lower = {lower}, upper={upper}')

mask_lower = df[df['longten'] < lower]
mask_lower # no lower value than lower bound

mask_upper = df[df['longten'] > upper]
mask_upper

#Change outliers to upper bound
df['new_longten'] = df['longten']
for i in mask_upper.index:
  df.loc[i,'new_longten'] = upper

mask2_upper = df[df['new_longten'] > upper] #check bounds changed
mask2_upper

#Box Plot for Balance

df['balance'].plot.box(whis=2) #no outliers

df

#Create new copy with new columns and existing columns you want to keep

df2 = df.drop(columns=['income', 'long_Month', 'longten'])
df2

#Question 7
#Please fill missing values in balance column with group mean. There are two different
#groups of columns in this dataset. To check whether to use group mean of a column with
#categorical data, study their group means of balance; if there are big differences between
#group means, the column is a good candidate. To check whether to use group mean of a
#column with numerical data, exam the density plots we have created, based on their
#patterns, select the column having similar distribution as the balance column. If a column
#eventually selected has numerical data, create bins first, then use bin mean to fill the
#missing value. Please make this decision by yourself after checking all candidates, and
#explain your decision.

#Check Categorical Columns


df2.groupby('region')['balance'].mean() #good candidate due to large difference between group mean

df2.groupby('internet')['balance'].mean() # good candidate due to large difference between group mean

df2.groupby('class')['balance'].mean() # bad candidate

#Fill in Group Mean for Good Category Candidates

#region column
df2['balance_with_region'] = df2['balance']
d = {1:2.93, 2:2.9,3:2.78}
df2['balance_with_region'] = df2.set_index('region')['balance'].fillna(d).reset_index()['balance']
df2.head(10)

#internet column
df2['balance_with_internet'] = df2['balance']
d = {0:2.93, 1:2.79}
df2['balance_with_internet'] = df2.set_index('internet')['balance'].fillna(d).reset_index()['balance']
df2.head(10)

#Check Numerical Columns

df2['balance'].plot.density()

df2['age'].plot.density() #good candidate, similar distribution

df2['new_income'].plot.density() # bad candidate

df2['new_long_Month'].plot.density() # bad candidate

df2['new_longten'].plot.density() # bad candidate

#Fill in Group Mean for Age Column

#binning
df2['age_bin_new'] = pd.qcut(df2['age'],4)
df2.groupby('age_bin_new')['balance'].mean()

df2['balance_with_age'] = df2['balance']

def replace_with_bin_mean(x):
  if True:
    x = x.mean()
  return x

df2['age_mean_bin'] = df2.groupby('age_bin_new')['balance'].transform(replace_with_bin_mean)

df2['balance_with_age'] = df2['balance_with_age'].fillna(df2['age_mean_bin'])

df2.head(10)

#Question 8 Smooth the new income column (after removing outliers) with mean of equal-width bins
#(the number of bins is 10)

df2['income_bin'] = pd.cut(df2['new_income'], 10) #cut into 10 equal bins
df2.groupby('income_bin')['new_income'].count()

#smooth by bin mean
df2.groupby('income_bin')['new_income'].mean()

df2.groupby('income_bin')['age'].apply(replace_with_bin_mean)

df2['smooth_income_bin_mean'] = df2.groupby('income_bin')['new_income'].transform(replace_with_bin_mean)
df2.head()

#smooth by boundaries of bins
df2.groupby('income_bin')['new_income'].max()

df2.groupby('income_bin')['new_income'].max().index

bin_results = (df2.groupby('income_bin')['new_income'].agg(['max','min']))
bin_results

#Question 9  Check whether there are columns positively related with each other. 

import seaborn as sns
df2.corr()
#all columns are positively correlated

#Question 10 Perform Min_Max Normalization and Z_score Normalization on all columns with numerical
#data, compare them


from sklearn import preprocessing
pd.set_option('precision',2)
np.set_printoptions(precision=2)

#min_max for age
min_max_scaler = preprocessing.MinMaxScaler()
df2_x_train = pd.DataFrame(df2['age'])
df2_x_train_MinMax = min_max_scaler.fit_transform(df2_x_train)
df2_x_train_MinMax

#z_score for age
x_train = df2['age']
x_scaled = preprocessing.scale(x_train)
x_scaled



#min_max for income
min_max_scaler = preprocessing.MinMaxScaler()
df2_x_train = pd.DataFrame(df2['new_income'])
df2_x_train_MinMax = min_max_scaler.fit_transform(df2_x_train)
df2_x_train_MinMax

#z_score for income
x_train = df2['new_income']
x_scaled = preprocessing.scale(x_train)
x_scaled

#min_max for long_Month
min_max_scaler = preprocessing.MinMaxScaler()
df2_x_train = pd.DataFrame(df2['new_long_Month'])
df2_x_train_MinMax = min_max_scaler.fit_transform(df2_x_train)
df2_x_train_MinMax

#z_score for long_Month
x_train = df2['new_long_Month']
x_scaled = preprocessing.scale(x_train)
x_scaled

#min_max for longten
min_max_scaler = preprocessing.MinMaxScaler()
df2_x_train = pd.DataFrame(df2['new_longten'])
df2_x_train_MinMax = min_max_scaler.fit_transform(df2_x_train)
df2_x_train_MinMax

#z_score for longten
x_train = df2['new_longten']
x_scaled = preprocessing.scale(x_train)
x_scaled

#min_max for balance
min_max_scaler = preprocessing.MinMaxScaler()
df2_x_train = pd.DataFrame(df2['balance'])
df2_x_train_MinMax = min_max_scaler.fit_transform(df2_x_train)
df2_x_train_MinMax

#z_score for balance
x_train = df2['balance']
x_scaled = preprocessing.scale(x_train)
x_scaled
